<!-- <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Causal Network</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #eee; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; }

    #3d-graph { position: fixed; inset: 0 0 0 0; } 
  </style>

  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <script type="module">
    import SpriteText from "https://esm.sh/three-spritetext";

    // ========= Group Colors: Automatic =========
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const Graph = new ForceGraph3D(document.getElementById('3d-graph'))
      .backgroundColor('#000')
      .linkDirectionalArrowLength(3.5)
      .linkDirectionalArrowRelPos(1)
      .linkCurvature(0.25)
      .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
      .linkDirectionalParticleWidth(4)
      .nodeAutoColorBy('group') // Automatically color by 'group'
      .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
      .nodeThreeObject(node => {
        const sprite = new SpriteText(String(node.id));
        sprite.material.depthWrite = false;
        sprite.color = node.color; // Set by nodeAutoColorBy
        sprite.textHeight = 8;
        sprite.center.y = -0.6;
        return sprite;
      })
      .nodeThreeObjectExtend(true);

    // === Hover Interaction (Node) ===
    Graph.onNodeHover(node => {
      if ((!node && !highlightNodes.size) || node === hoverNode) return;

      highlightNodes.clear();
      if (node) {
        highlightNodes.add(node);
        node.neighbors?.forEach(nei => highlightNodes.add(nei));
        node.links?.forEach(l => highlightLinks.add(l));
      }
      hoverNode = node || null;
      updateHighlight();
    });

    // === Hover Interaction (Link) ===
    Graph.onLinkHover(link => {
      highlightNodes.clear();
      highlightLinks.clear();
      if (link) {
        highlightLinks.add(link);
        highlightNodes.add(link.source);
        highlightNodes.add(link.target);
      }
      updateHighlight();
    });

    function updateHighlight() {
      Graph
        .nodeColor(node => {
          if (highlightNodes.has(node)) {
            return node === hoverNode ? '#ff0000' : '#ffa000';
          }
          return node.color;
        })
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }

    Graph.onNodeClick(node => {
      // Focus camera
      const distance = 800; // Camera distance from target
      const distRatio = 1 + distance / Math.hypot(node.x || 0, node.y || 0, node.z || 0);
      const newPos = (node.x || node.y || node.z)
        ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
        : { x: 0, y: 0, z: distance };

      Graph.cameraPosition(newPos, node, 3000);
    });

    fetch('../miserables.json') 
      .then(r => r.json())
      .then(data => {
        const nodeById = new Map(data.nodes.map(n => [n.id, n]));
        data.nodes.forEach(n => { n.neighbors = []; n.links = []; });
        data.links.forEach(l => {
          const a = typeof l.source === 'object' ? l.source : nodeById.get(l.source);
          const b = typeof l.target === 'object' ? l.target : nodeById.get(l.target);
          if (!a || !b) return;
          a.neighbors.push(b); b.neighbors.push(a);
          a.links.push(l);    b.links.push(l);
        });

        Graph.graphData(data);
        Graph.d3Force('charge').strength(-400);
      });
  </script>
</body>
</html> -->



<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Causal Network</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #eee; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; }
    #3d-graph { position: fixed; inset: 0 0 0 0; } 
  </style>

  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <script type="module">
    import SpriteText from "https://esm.sh/three-spritetext";

    // ========= Group Colors: Automatic =========
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const Graph = new ForceGraph3D(document.getElementById('3d-graph'))
      .backgroundColor('#000')
      .linkDirectionalArrowLength(3.5)
      .linkDirectionalArrowRelPos(1)
      .linkCurvature(0.25)
      .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
      .linkDirectionalParticleWidth(4)
      .nodeAutoColorBy('group')
      .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
      .nodeThreeObject(node => {
        const sprite = new SpriteText(String(node.id));
        sprite.material.depthWrite = false;
        sprite.color = node.color; // Set by nodeAutoColorBy
        sprite.textHeight = 8;
        sprite.center.y = -0.6;
        return sprite;
      })
      .nodeThreeObjectExtend(true);

    // === Hover Interaction (Node) ===
    Graph.onNodeHover(node => {
      if ((!node && !highlightNodes.size) || node === hoverNode) return;

      highlightNodes.clear();
      if (node) {
        highlightNodes.add(node);
        node.neighbors?.forEach(nei => highlightNodes.add(nei));
        node.links?.forEach(l => highlightLinks.add(l));
      }
      hoverNode = node || null;
      updateHighlight();
    });

    // === Hover Interaction (Link) ===
    Graph.onLinkHover(link => {
      highlightNodes.clear();
      highlightLinks.clear();
      if (link) {
        highlightLinks.add(link);
        highlightNodes.add(link.source);
        highlightNodes.add(link.target);
      }
      updateHighlight();
    });

    function updateHighlight() {
      Graph
        .nodeColor(node => {
          if (highlightNodes.has(node)) {
            return node === hoverNode ? '#ff0000' : '#ffa000';
          }
          return node.color;
        })
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }

    // ====== åŸæ¥çš„â€œç‚¹å‡»èšç„¦â€ï¼ˆä¿ç•™ï¼›ä½ ä¹Ÿå¯ä»¥åˆ æ‰ï¼‰======
    Graph.onNodeClick(node => {
      focusNode(node, 800, 3000);
    });

    // ---------- ğŸ” è‡ªåŠ¨éšæœºè·³è·ƒï¼šå·¥å…·å‡½æ•° ----------
    function focusNode(node, distance = 800, duration = 3000) {
      // è®¡ç®—ç›®æ ‡ç›¸æœºä½ç½®ï¼šä»è¯¥ node é€€åä¸€å®šè·ç¦»
      const x = node.x || 0, y = node.y || 0, z = node.z || 0;
      const distRatio = 1 + distance / Math.hypot(x, y, z || 1);
      const newPos = (x || y || z)
        ? { x: x * distRatio, y: y * distRatio, z: z * distRatio }
        : { x: 0, y: 0, z: distance };

      Graph.cameraPosition(newPos, node, duration);
    }

    // ---------- ğŸ” è‡ªåŠ¨éšæœºè·³è·ƒï¼šæ ¸å¿ƒé€»è¾‘ ----------
    let autoHopTimer = null;
    let lastNodeId = null;

    function startAutoHop(intervalMs = 4000, distance = 800, duration = 2000) {
      stopAutoHop(); // é˜²æ­¢é‡å¤å®šæ—¶
      const hop = () => {
        const data = Graph.graphData?.();
        const nodes = data?.nodes || [];
        if (!nodes.length) {
          // æ•°æ®æœªåˆ°ä½ï¼Œç¨åé‡è¯•
          autoHopTimer = setTimeout(hop, 1000);
          return;
        }

        // éšæœºé€‰ä¸€ä¸ªä¸ä¸Šæ¬¡ä¸åŒçš„èŠ‚ç‚¹
        let pick = null;
        if (nodes.length === 1) {
          pick = nodes[0];
        } else {
          for (let tries = 0; tries < 5; tries++) {
            const cand = nodes[Math.floor(Math.random() * nodes.length)];
            if (cand.id !== lastNodeId) { pick = cand; break; }
          }
          if (!pick) pick = nodes[Math.floor(Math.random() * nodes.length)];
        }
        lastNodeId = pick.id;

        focusNode(pick, distance, duration);
        autoHopTimer = setTimeout(hop, intervalMs);
      };
      hop();
    }

    function stopAutoHop() {
      if (autoHopTimer) {
        clearTimeout(autoHopTimer);
        autoHopTimer = null;
      }
    }

    // ï¼ˆå¯é€‰ï¼‰å½“ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»æ—¶ï¼ŒçŸ­æš‚åœæ­¢è‡ªåŠ¨è·³è·ƒä»¥é¿å…â€œæ‰“æ¶â€
    Graph.onNodeClick(() => {
      // å¦‚éœ€ä¸åœä¹Ÿå¯ä»¥åˆ æ‰ä¸‹é¢ä¸‰è¡Œ
      stopAutoHop();
      setTimeout(() => startAutoHop(), 3500);
    });

    // ---------- åŠ è½½æ•°æ® ----------
    fetch('./hpp_causal_network_fixed.json') 
      .then(r => r.json())
      .then(data => {
        const nodeById = new Map(data.nodes.map(n => [n.id, n]));
        data.nodes.forEach(n => { n.neighbors = []; n.links = []; });
        data.links.forEach(l => {
          const a = typeof l.source === 'object' ? l.source : nodeById.get(l.source);
          const b = typeof l.target === 'object' ? l.target : nodeById.get(l.target);
          if (!a || !b) return;
          a.neighbors.push(b); b.neighbors.push(a);
          a.links.push(l);    b.links.push(l);
        });

        Graph.graphData(data);
        Graph.d3Force('charge').strength(-400);

        // ---------- ğŸ” å¯åŠ¨è‡ªåŠ¨éšæœºè·³è·ƒ ----------
        startAutoHop(4000, 400, 2000); // é—´éš”4ç§’ã€è·ç¦»800ã€åŠ¨ç”»2ç§’
      });
  </script>
</body>
</html>
