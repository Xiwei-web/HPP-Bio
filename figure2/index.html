<head>
  <meta charset="utf-8" />
  <style> body { margin: 0; } </style>
  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <script type="module">
    import SpriteText from "https://esm.sh/three-spritetext";

    // ========= 分组配色：改为自动分配 =========
    // 移除了手动的 PALETTE, groupColorMap, 和 colorByGroup 逻辑

    // ========= 高亮状态 =========
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const Graph = new ForceGraph3D(document.getElementById('3d-graph'))
      .backgroundColor('#000')                   // 黑色背景
      .linkDirectionalArrowLength(3.5)
      .linkDirectionalArrowRelPos(1)
      .linkCurvature(0.25)
      .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
      .linkDirectionalParticleWidth(4)
      .nodeAutoColorBy('group') // <--- 保持自动上色
      // 
      .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
      .nodeThreeObject(node => {
        const sprite = new SpriteText(String(node.id));
        sprite.material.depthWrite = false;
        // 同样，使用 node.color 作为文字颜色
        // node.color 将由 nodeAutoColorBy 填充
        sprite.color = node.color; 
        sprite.textHeight = 8;
        sprite.center.y = -0.6;
        return sprite;
      })
      .nodeThreeObjectExtend(true);

    // 悬停交互（节点）
    Graph.onNodeHover(node => {
      if ((!node && !highlightNodes.size) || node === hoverNode) return;

      highlightNodes.clear();
      highlightLinks.clear();
      if (node) {
        highlightNodes.add(node);
        node.neighbors?.forEach(nei => highlightNodes.add(nei));
        node.links?.forEach(l => highlightLinks.add(l));
      }
      hoverNode = node || null;
      updateHighlight();
    });

    // 悬停交互（边）
    Graph.onLinkHover(link => {
      highlightNodes.clear();
      highlightLinks.clear();
      if (link) {
        highlightLinks.add(link);
        highlightNodes.add(link.source);
        highlightNodes.add(link.target);
      }
      updateHighlight();
    });

    function updateHighlight() {
      // 触发高亮状态的重绘
      Graph
        .nodeColor(node => { // <--- 
          if (highlightNodes.has(node)) {
            // 保持高亮逻辑
            return node === hoverNode ? '#ff0000' : '#ffa000';
          }
          // 否则，使用由 nodeAutoColorBy 分配的颜色
          // 此时 node.color 应该已经被 nodeAutoColorBy 正确填充
          return node.color; 
        })
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }

    // ========= 点击节点：镜头聚焦（click-to-focus） =========
    Graph.onNodeClick(node => {
      const distance = 300; // 摄像机与目标点的期望距离，可调
      const distRatio = 1 + distance / Math.hypot(node.x || 0, node.y || 0, node.z || 0);

      // 若坐标尚未稳定（可能是 0,0,0），设置一个保底位姿
      const newPos = (node.x || node.y || node.z)
        ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
        : { x: 0, y: 0, z: distance };

      // 平滑移动并看向该节点
      Graph.cameraPosition(
        newPos,   // 摄像机新位置
        node,     // lookAt 目标
        3000      // 动画时长（毫秒）
      );
    });

    // ====== 加载数据 -> 构建邻接 -> 渲染 ======
    // 保持了您原有的 fetch 和数据处理逻辑
    fetch('../hpp_causal_network_dense.json')
      .then(r => r.json())
      .then(data => {
        const nodeById = new Map(data.nodes.map(n => [n.id, n]));
        data.nodes.forEach(n => { n.neighbors = []; n.links = []; });
        data.links.forEach(l => {
          const a = typeof l.source === 'object' ? l.source : nodeById.get(l.source);
          const b = typeof l.target === 'object' ? l.target : nodeById.get(l.target);
          if (!a || !b) return;
          a.neighbors.push(b); b.neighbors.push(a);
          a.links.push(l);    b.links.push(l);
        });

        Graph.graphData(data);
        Graph.d3Force('charge').strength(-400);
      });
  </script>
</body>

