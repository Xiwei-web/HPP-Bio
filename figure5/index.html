<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Causal Network (with Synchronized Colors & Info Panel)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ===== Base Styles ===== */
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #eef2ff;         /* 页面背景 */
      color: #333;                  /* 浅底默认文字色 */
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
    }
    /* 预留 360px 给右侧信息面板 */
    #3d-graph { position: fixed; inset: 0 360px 0 0; }

    /* ===== Node Info Panel — 浅色面板配色 ===== */
    #node-panel.panel {
      position: fixed; top: 0; right: 0;
      width: 360px; max-width: 85vw; height: 100vh;
      background: #eef2ff;   /* 浅色背景 */
      color: #1f2937;                       /* 面板文字 */
      overflow-y: auto; padding: 16px 20px 24px;
      box-shadow: -12px 0 24px rgba(0,0,0,0.15);
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    #node-panel.hidden { display: none; }
    #panel-close {
      position: absolute; top: 10px; right: 10px;
      background: transparent; color: #6b7280; border: 0; font-size: 18px; cursor: pointer;
    }
    #node-panel h2 { margin: 8px 0 6px; font-size: 18px; color: #111827; }
    #node-panel a { color: #2563eb; word-break: break-all; }
    #node-panel .meta { font-size: 12px; color: #6b7280; margin-bottom: 12px; }
    #node-panel .pill {
      display: inline-block; padding: 2px 8px; border: 1px solid #e5e7eb;
      border-radius: 999px; margin: 0 8px 8px 0; font-size: 12px; color:#374151;
      background: #ffffffaa;
    }
    #panel-content ul { margin: 4px 0; padding-left: 20px; list-style-type: none; }
    #panel-content ul li { padding: 2px 0; font-size: 14px; }
    #panel-content ul li strong { color: #2563eb; margin-right: 6px; }
    #panel-content ul ul { list-style-type: disc; }

    /* 小屏：面板覆盖，画布全屏 */
    @media (max-width: 768px) {
      #3d-graph { inset: 0; }
      #node-panel.panel { width: 85vw; }
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <div id="3d-graph"></div>

  <div id="node-panel" class="panel hidden">
    <button id="panel-close">✕</button>
    <div id="panel-content"></div>
  </div>

  <script type="module">
    import SpriteText from "https://esm.sh/three-spritetext";

    // ========= Highlight states =========
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;      // 当前鼠标悬停节点
    let activeNode = null;     // 当前“激活/聚焦”节点（自动/点击）

    const elem = document.getElementById('3d-graph');

    // ===== 统一颜色来源：按 COLOR_BY 字段分组上色 =====
    const COLOR_BY = 'group';  // 想按其他字段分组（如 'user'），改这里即可
    const PALETTE = [
      "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd",
      "#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"
    ];
    const colorMap = new Map();
    function colorForGroup(val) {
      const key = val == null ? '__NA__' : String(val);
      if (!colorMap.has(key)) {
        colorMap.set(key, PALETTE[colorMap.size % PALETTE.length]);
      }
      return colorMap.get(key);
    }

    const Graph = new ForceGraph3D(elem)
      .backgroundColor('#eef2ff')            // Three 场景背景
      .linkDirectionalArrowLength(3.5)
      .linkDirectionalArrowRelPos(1)
      .linkCurvature(0.25)
      .linkDirectionalParticles(l => highlightLinks.has(l) ? 4 : 0)
      .linkDirectionalParticleWidth(4)
      .linkColor(l => highlightLinks.has(l) ? '#666666' : '#BBBBBB') // 高亮线更深，普通线浅灰
      .linkWidth(l => highlightLinks.has(l) ? 4 : 1)
      .nodeThreeObject(node => {
        const sprite = new SpriteText(String(node.id)); // 也可改为 node.user / node.title
        sprite.material.depthWrite = false;

        // 统一基础色：球体与文字使用同一颜色源
        const base = colorForGroup(node[COLOR_BY]);
        sprite.color = base;
        sprite.textHeight = 8;
        sprite.center.y = -0.6;

        // 记录引用与状态，便于后续同步改色
        node.__sprite     = sprite;
        node.__baseColor  = base; // 基础色（未高亮）
        node.__paintColor = base; // 当前实际用于球体着色的颜色
        return sprite;
      })
      .nodeThreeObjectExtend(true)
      // 球体颜色也从 __paintColor 读取，确保与文字一致
      .nodeColor(n => n.__paintColor)
      .onNodeHover(node => {
        if ((!node && !highlightNodes.size) || node === hoverNode) return;
        hoverNode = node || null;
        if (hoverNode) fillHighlightFromNode(hoverNode);
        else fillHighlightFromNode(activeNode);
        updateHighlight();
        elem.style.cursor = node ? 'pointer' : null;
      })
      .onLinkHover(link => {
        highlightNodes.clear();
        highlightLinks.clear();
        if (link) {
          highlightLinks.add(link);
          highlightNodes.add(link.source);
          highlightNodes.add(link.target);
        } else {
          if (hoverNode) fillHighlightFromNode(hoverNode);
          else fillHighlightFromNode(activeNode);
        }
        updateHighlight();
      });

    // ====== 着色助手：同步“球体 + 文字”的颜色 ======
    function paintNode(n, hex) {
      n.__paintColor = hex;
      if (n.__sprite && n.__sprite.color !== hex) n.__sprite.color = hex;
    }

    // ====== 根据高亮集合刷新节点与连线 ======
    function updateHighlight() {
      const primary = hoverNode || activeNode;     // 主高亮节点：优先悬停，否则激活
      const nodes = Graph.graphData()?.nodes || [];

      for (const n of nodes) {
        if (highlightNodes.has(n)) {
          paintNode(n, n === primary ? '#ff0000' : '#ffa000'); // 主=红，相邻=琥珀
        } else {
          paintNode(n, n.__baseColor); // 恢复基础色
        }
      }

      Graph
        .nodeColor(n => n.__paintColor)
        .linkColor(l => highlightLinks.has(l) ? '#666666' : '#BBBBBB')
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles());
    }

    function fillHighlightFromNode(node) {
      highlightNodes.clear();
      highlightLinks.clear();
      if (!node) return;
      highlightNodes.add(node);
      node.neighbors?.forEach(nei => highlightNodes.add(nei));
      node.links?.forEach(l => highlightLinks.add(l));
    }

    // ====== 递归把对象转为 HTML 列表（用于 content 为对象时）======
    function objectToHtml(obj) {
      if (obj === null) return '<em>null</em>';
      if (typeof obj !== 'object') return String(obj);
      if (Array.isArray(obj)) return `<ul>${obj.map(item => `<li>${objectToHtml(item)}</li>`).join('')}</ul>`;
      return `<ul>${Object.entries(obj).map(([k,v]) => `<li><strong>${k}:</strong> ${objectToHtml(v)}</li>`).join('')}</ul>`;
    }

    // ====== Info Panel ======
    const panelEl = document.getElementById('node-panel');
    const panelContentEl = document.getElementById('panel-content');
    document.getElementById('panel-close').onclick = () => panelEl.classList.add('hidden');
    Graph.onBackgroundClick(() => panelEl.classList.add('hidden'));

    function showNodeInfo(node) {
      if (node?.content) {
        if (typeof node.content === 'string') {
          panelContentEl.innerHTML = node.content;
        } else if (typeof node.content === 'object') {
          const html = objectToHtml(node.content);
          panelContentEl.innerHTML = `
            <h2>${node.id}</h2>
            <div class="meta">
              <span class="pill">Group: ${node.group ?? 'N/A'}</span>
              ${node.neighbors ? `<span class="pill">Degree: ${node.neighbors.length}</span>` : ''}
            </div>
            <hr style="border:none; border-top:1px solid #e5e7eb; margin:16px 0;">
            ${html}
          `;
        } else {
          panelContentEl.innerHTML = `<p>Error: Unknown content format.</p>`;
        }
      } else {
        const degree = node.neighbors ? node.neighbors.length : 0;
        const title = node.title || String(node.id);
        const desc = node.desc || '';
        const url = node.url;
        panelContentEl.innerHTML = `
          <h2>${title}</h2>
          <div class="meta">
            <span class="pill">id: ${String(node.id)}</span>
            <span class="pill">group: ${node.group ?? '-'}</span>
            <span class="pill">degree: ${degree}</span>
          </div>
          ${desc ? `<p>${desc}</p>` : ''}
          ${url ? `<p><a href="${url}" target="_blank" rel="noopener">More Info ↗</a></p>` : ''}
        `;
      }
      panelEl.classList.remove('hidden');
    }

    // ====== 聚焦到节点（点击或自动） ======
    function focusNode(node, distance = 400, duration = 4000) {
      const x = node.x || 0, y = node.y || 0, z = node.z || 0;
      const distRatio = 1 + distance / Math.hypot(x, y, z || 1);
      const newPos = (x || y || z)
        ? { x: x * distRatio, y: y * distRatio, z: z * distRatio }
        : { x: 0, y: 0, z: distance };
      Graph.cameraPosition(newPos, node, duration);
    }

    function setActiveNode(node) {
      activeNode = node || null;
      if (!hoverNode) {          // 没有悬停时，用激活节点高亮
        fillHighlightFromNode(activeNode);
        updateHighlight();
      }
      if (node) showNodeInfo(node);   // 同步更新面板内容
    }

    // ====== 点击节点：设为激活 + 显示面板 + 聚焦 ======
    Graph.onNodeClick(node => {
      setActiveNode(node);
      focusNode(node, 300, 3000);
    });

    // ====== 随机自动 focus （含面板同步）======
    let autoFocusTimer = null, lastNodeId = null;
    function startAutoFocus(intervalMs = 5000, distance = 400, duration = 4000) {
      stopAutoFocus();
      const hop = () => {
        const nodes = Graph.graphData()?.nodes || [];
        if (!nodes.length) { autoFocusTimer = setTimeout(hop, 1000); return; }

        let pick = null;
        if (nodes.length === 1) pick = nodes[0];
        else {
          for (let tries = 0; tries < 5; tries++) {
            const cand = nodes[Math.floor(Math.random() * nodes.length)];
            if (cand.id !== lastNodeId) { pick = cand; break; }
          }
          if (!pick) pick = nodes[Math.floor(Math.random() * nodes.length)];
        }
        lastNodeId = pick.id;

        setActiveNode(pick);              // 设置激活节点并刷新高亮 & 面板
        focusNode(pick, distance, duration);

        autoFocusTimer = setTimeout(hop, intervalMs);
      };
      hop();
    }
    function stopAutoFocus() {
      if (autoFocusTimer) { clearTimeout(autoFocusTimer); autoFocusTimer = null; }
    }

    // ====== 加载数据，构建邻接关系并启动渲染/自动聚焦 ======
    fetch('./hpp_causal_network_fixed.json')
      .then(r => r.json())
      .then(data => {
        const nodeById = new Map(data.nodes.map(n => [n.id, n]));
        data.nodes.forEach(n => { n.neighbors = []; n.links = []; });
        data.links.forEach(l => {
          const a = typeof l.source === 'object' ? l.source : nodeById.get(l.source);
          const b = typeof l.target === 'object' ? l.target : nodeById.get(l.target);
          if (!a || !b) return;
          a.neighbors.push(b); b.neighbors.push(a);
          a.links.push(l);    b.links.push(l);
        });

        Graph.graphData(data);
        Graph.d3Force('charge').strength(-400);

        // 启动随机自动 focus（镜头 + 面板同步）
        startAutoFocus(5000, 300, 2000);
      });
  </script>
</body>
</html>
